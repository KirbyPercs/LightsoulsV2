local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "LightSoulsV2 üèñ | Hood Modded",
   LoadingTitle = "LightSoulsV2 Hub",
   LoadingSubtitle = "by blade",
   ConfigurationSaving = {
      Enabled = false,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "LightSouls Scripts"
   },
   Discord = {
      Enabled = true,
      Invite = "CDtZAEp8E8", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
      RememberJoins = false -- Set this to false to make them join the discord every time they load it up
   },
   KeySystem = true, -- Set this to true to use our key system
   KeySettings = {
      Title = "LightSouls Key System",
      Subtitle = "Key in the discord server.",
      Note = "join the discord server to obtain the key!",
      FileName = "key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"BLADEONTOP"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local MainTab = Window:CreateTab("üëªMainüëª", nil) -- Title, Image
local MainSection = MainTab:CreateSection("Main")

Rayfield:Notify({
   Title = "LightSouls Had Loaded",
   Content = "Make sure to join the discord",
   Duration = 3,
   Image = nil,
   Actions = { -- Notification Buttons
      Ignore = {
         Name = "Okay!",
         Callback = function()
         print("The user tapped Okay!")
      end
   },
},
})

local Button = MainTab:CreateButton({
   Name = "Speed",
   Callback = function()
   player = game.Players.LocalPlayer
    player.Character.Humanoid.WalkSpeed = 200
   end,
})

local Button = MainTab:CreateButton({
   Name = "Fly",
   Callback = function()
   -- fly made by KirbyX and Blade
loadstring("\108\111\97\100\115\116\114\105\110\103\40\103\97\109\101\58\72\116\116\112\71\101\116\40\40\39\104\116\116\112\115\58\47\47\103\105\115\116\46\103\105\116\104\117\98\117\115\101\114\99\111\110\116\101\110\116\46\99\111\109\47\109\101\111\122\111\110\101\89\84\47\98\102\48\51\55\100\102\102\57\102\48\97\55\48\48\49\55\51\48\52\100\100\100\54\55\102\100\99\100\51\55\48\47\114\97\119\47\101\49\52\101\55\52\102\52\50\53\98\48\54\48\100\102\53\50\51\51\52\51\99\102\51\48\98\55\56\55\48\55\52\101\98\51\99\53\100\50\47\97\114\99\101\117\115\37\50\53\50\48\120\37\50\53\50\48\102\108\121\37\50\53\50\48\50\37\50\53\50\48\111\98\102\108\117\99\97\116\111\114\39\41\44\116\114\117\101\41\41\40\41\10\10")()
   end,
})

local Button = MainTab:CreateButton({
   Name = "godmode",
   Callback = function()
   _G.bypass = true -- make it to false in order to reset / Default : true
_G.godmode = false -- make the bypass false too in order to disable godmode and reset
_G.invisible = false -- make the bypass false too in order to disable invisble and reset hide in some place and make it true
 
local Hook
Hook = hookfunction(getrawmetatable(game).__namecall, newcclosure(function(self, ...)
  local args = {...}
  if self.Name == "RemoteEvent" and _G.bypass == true  then
      if args[1] == "Reset"  then
          return wait(9e9)
      elseif _G.bypass == false then
        return Hook(self,...)
      end
  end
  return Hook(self, ...)
end))
 
-- bypass must be enabled to get the godmode effect in order to disable godmode you need to reset
 
while _G.godmode do wait(1) pcall(function()
    if _G.godmode == false then return  end
    game:GetService("Players").LocalPlayer.Character.BindableEvent:Destroy()
  end)
end
 
if _G.invisible then
    if _G.invisible == false then return end
    if game:GetService("Players").LocalPlayer.Character.LowerTorso:FindFirstChild'Root' then
game:GetService("Players").LocalPlayer.Character.LowerTorso.Root:Remove()
end
if game:GetService("Players").LocalPlayer.Character.UpperTorso:FindFirstChild'Waist' then
game:GetService("Players").LocalPlayer.Character.UpperTorso.Waist:Remove()
end
end
   end,
})

local Button = MainTab:CreateButton({
   Name = "GodmodeV2",
   Callback = function()
    --This script is made by TheMotoriousBIG (roblox)
--God Mode is unable to kill people in-game.
 
local player = game.Players.LocalPlayer
 
if player.Character then
 
if player.Character:FindFirstChild("Humanoid") then
 
player.Character.Humanoid.Name = "1"
 
end
 
local l = player.Character["1"]:Clone()
 
l.Parent = player.Character
 
l.Name = "Humanoid"; wait(0.1)
 
player.Character["1"]:Destroy()
 
workspace.CurrentCamera.CameraSubject = player.Character.Humanoid
 
player.Character.Animate.Disabled = true; wait(0.1)
 
player.Character.Animate.Disabled = false
 
end
 
print("Godmode Has Loaded.")
   end,
})

local Button = MainTab:CreateButton({
   Name = "CFrame Speed",
   Callback = function()
--CFrame Speed Script

--Function to calculate the speed of a CFrame movement
local function calculateCFrameSpeed(startCFrame, endCFrame, deltaTime)
    local positionDelta = endCFrame.Position - startCFrame.Position
    local rotationDelta = endCFrame - endCFrame.Position - (startCFrame - startCFrame.Position)
    
    local linearSpeed = positionDelta.Magnitude / deltaTime
    local angularSpeed = rotationDelta.Magnitude / deltaTime
    
    return linearSpeed, angularSpeed
end

-- Example usage
local startCFrame = CFrame.new(0, 0, 0)
local endCFrame = CFrame.new(5, 0, 0) + CFrame.Angles(0, math.pi/2, 0)
local deltaTime = 1 -- Time in seconds

local linearSpeed, angularSpeed = calculateCFrameSpeed(startCFrame, endCFrame, deltaTime)

print("Linear Speed:", linearSpeed)
print("Angular Speed:", angularSpeed)
   end,
})

local ClientSidedTab = Window:CreateTab("‚ú®Client sided‚ú®", nil) -- Title, Image
local ClientSidedSection = ClientSidedTab:CreateSection("Client Sided Stuff")

local Button = ClientSidedTab:CreateButton({
   Name = "headless",
   Callback = function()
  while wait() do
    me = game:GetService("Players").LocalPlayer.Character
    if me:FindFirstChild("Head") and me:FindFirstChild("Humanoid") then
        me.Head.MeshId = "rbxassetid://6686307858" --Yeah whatever it work if its also nil
    end
end
   end,
})

local Button = ClientSidedTab:CreateButton({
   Name = "Korblox",
   Callback = function()
   local ply = game.Players.LocalPlayer
local chr = ply.Character
chr.RightLowerLeg.MeshId = "902942093"
chr.RightLowerLeg.Transparency = "1"
chr.RightUpperLeg.MeshId = "http://www.roblox.com/asset/?id=902942096"
chr.RightUpperLeg.TextureID = "http://roblox.com/asset/?id=902843398"
chr.RightFoot.MeshId = "902942089"
chr.RightFoot.Transparency = "1"

   end,
})

local Button = ClientSidedTab:CreateButton({
   Name = "Button Example",
   Callback = function()
   local You = "ericthefabulous" local head = workspace[You].Head:Clone() local model = Instance.new("Model",workspace) local humanoid = Instance.new("Humanoid",model) head.Parent = model model.Name = You.." [üëë] Shoota" humanoid.MaxHealth = 0 local w = Instance.new("Weld",model) w.Part0,w.Part1 = workspace[You].Head,head
   end,
})

local Button = ClientSidedTab:CreateButton({
   Name = "Spiderman",
   Callback = function()
   local ScreenGui = Instance.new("ScreenGui")
local main = Instance.new("Frame")
local TextLabel = Instance.new("TextLabel")
local TextButton = Instance.new("TextButton")
local TextButton_2 = Instance.new("TextButton")
 
--Properties:
 
ScreenGui.Parent = game.CoreGui
 
main.Name = "main"
main.Parent = ScreenGui
main.BackgroundColor3 = Color3.fromRGB(31, 31, 31)
main.Position = UDim2.new(0.140581071, 0, 0.371717185, 0)
main.Size = UDim2.new(0, 841, 0, 241)
main.Active = true
main.Draggable = true
 
TextLabel.Parent = main
TextLabel.BackgroundColor3 = Color3.fromRGB(63, 63, 63)
TextLabel.Size = UDim2.new(0, 841, 0, 50)
TextLabel.Font = Enum.Font.SourceSans
TextLabel.Text = "Blades Spiderman Gui"
TextLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
TextLabel.TextSize = 19.000
 
TextButton.Parent = main
TextButton.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
TextButton.Position = UDim2.new(0.0416171253, 0, 0.477178425, 0)
TextButton.Size = UDim2.new(0, 256, 0, 73)
TextButton.Font = Enum.Font.SourceSans
TextButton.Text = "spider-man power"
TextButton.TextColor3 = Color3.fromRGB(0, 0, 0)
TextButton.TextSize = 19.000
TextButton.MouseButton1Down:connect(function()
	loadstring(game:HttpGet(('https://raw.githubusercontent.com/ItsDishan/SpidermanScript/main/Spider-Man'), true))()
end)
 
TextButton_2.Parent = main
TextButton_2.BackgroundColor3 = Color3.fromRGB(66, 66, 66)
TextButton_2.Position = UDim2.new(0.659928679, 0, 0.477178425, 0)
TextButton_2.Size = UDim2.new(0, 256, 0, 73)
TextButton_2.Font = Enum.Font.SourceSans
TextButton_2.Text = "spider-man suit"
TextButton_2.TextColor3 = Color3.fromRGB(0, 0, 0)
TextButton_2.TextSize = 19.000
TextButton_2.MouseButton1Down:connect(function()
	local plr = game:GetService('Players').LocalPlayer
	local mouse = plr:GetMouse()
	local chr = plr.Character
	local rope = nil
	local working = false
	local working2 = false
	local forward = false
	local backward = false
	local shooting = false
	local left = false
	local right = false
	local crawling = false
	local active = true
	local wing1 = nil
	local wing2 = nil
	local hats = {}
	local gui = Instance.new('ScreenGui')
	gui.Parent = plr.PlayerGui
	gui.Name = "Spiderman"
	gui.ResetOnSpawn = false
	local frame = Instance.new('Frame',gui)
	frame.Size = UDim2.new(0.2,0,0.2,0)
	frame.Position = UDim2.new(0,0,0.9,0)
	frame.BackgroundColor3 = Color3.fromRGB(255, 66, 66)
	frame.BorderSizePixel = 4
	frame.BorderColor3 = Color3.fromRGB(66, 134, 244)
	frame.Active = true
	frame.Draggable = true
	local txt = Instance.new('TextLabel',frame)
	txt.Text = "Spiderman Gui"
	txt.TextColor3 = Color3.fromRGB(66, 134, 244)
	txt.Size = UDim2.new(1,0,0.3,0)
	txt.TextScaled = true
	txt.BackgroundTransparency = 1
	local but = Instance.new('TextButton',frame)
	but.Text = "Toggle Suit"
	but.TextColor3 = Color3.fromRGB(255, 66, 66)
	but.Size = UDim2.new(0.7,0,0.3,0)
	but.Position = UDim2.new(0.15,0,0.5,0)
	but.BorderSizePixel = 0
	but.TextScaled = true
	but.BackgroundColor3 = Color3.fromRGB(66, 134, 244)
	but.MouseButton1Down:connect(function()
		active = not active
	end)
	local txt2 = Instance.new('TextLabel',frame)
	txt2.Text = "Toggle wall climb on with C."
	txt2.TextColor3 = Color3.fromRGB(66, 134, 244)
	txt2.Size = UDim2.new(1,0,0.15,0)
	txt2.Position = UDim2.new(0,0,0.85,0)
	txt2.TextScaled = true
	txt2.BackgroundTransparency = 1
	function webshot(char)
		local haaaaaaaaa = coroutine.wrap(function()
			if char:FindFirstChildOfClass('Humanoid').Health > 0 then
				for i,v in pairs(char:GetChildren()) do
					local partz = {Enum.NormalId.Back,Enum.NormalId.Right,Enum.NormalId.Left,Enum.NormalId.Top,Enum.NormalId.Bottom,Enum.NormalId.Front}
					if v:IsA('Part') and v.Transparency ~= 1 and v.Name ~= "Head" then
						for a,c in pairs(partz) do
							local dec = Instance.new('Decal',v)
							dec.Texture = 'http://www.roblox.com/asset/?id=148633485'
							dec.Face = c
						end
					end
				end
				char:FindFirstChildOfClass('Humanoid').Health = char:FindFirstChildOfClass('Humanoid').Health - char:FindFirstChildOfClass('Humanoid').MaxHealth*0.3
				if char:FindFirstChild('HumanoidRootPart') then
					local heyyyy = nil
					if char:FindFirstChild('Animate') then
						heyyyy = char.Animate:Clone()
						char.Animate:Destroy()
					end
					char:FindFirstChildOfClass('Humanoid').PlatformStand = true
					local ahhhhhhh = true
					char.HumanoidRootPart.CFrame = CFrame.new(char.HumanoidRootPart.Position)*CFrame.Angles(0,0,math.pi/2)
					if char:FindFirstChildOfClass('Humanoid') then
						char:FindFirstChildOfClass('Humanoid').Changed:connect(function(change)
							if change == "PlatformStand" and ahhhhhhh then
								char:FindFirstChildOfClass('Humanoid').PlatformStand = true
							end
						end)
					end
					wait(15)
					ahhhhhhh = false
					if char:FindFirstChildOfClass('Humanoid') then
						char:FindFirstChildOfClass('Humanoid').PlatformStand = false
					end
					if force then
						force:Destroy()
					end
					if heyyyy then
						heyyyy.Parent = char
					end
					for i,v in pairs(char:GetChildren()) do
						if v.Name ~= "Head" then
							for a,c in pairs(v:GetChildren()) do
								if c:IsA('Decal') then
									c:Destroy()
								end
							end
						end
					end
				end
			end
		end)
		haaaaaaaaa()
	end
	mouse.KeyDown:connect(function(key)
		if key == "f" then
			if rope == nil then
				if plr.Character and mouse.Hit and mouse.Target and plr.Character:FindFirstChild('Head') and plr.Character:FindFirstChild('Left Arm') and plr.Character:FindFirstChild('Torso') and plr.Character.Torso:FindFirstChild('Left Shoulder') then
					if game.CoreGui:FindFirstChild('hekking spiderman') then
						game.CoreGui:FindFirstChild('hekking spiderman'):Destroy()
					end
					local Head = plr.Character.Head
					local RightShoulder = plr.Character.Torso["Left Shoulder"]
					local RightArm = plr.Character["Left Arm"]
					local MousePosition = mouse.Hit.p
					local ToMouse = (MousePosition - Head.Position).unit
					local Angle = math.acos(ToMouse:Dot(Vector3.new(0, -1, 0)))
					local FromRightArmPos = (Head.Position + Head.CFrame:vectorToWorldSpace(Vector3.new(((Head.Size.X / 2) + (RightArm.Size.X / 2)), ((Head.Size.Y / 2) - (RightArm.Size.Z / 2)), 0)))
					local ToMouseRightArm = ((MousePosition - FromRightArmPos) * Vector3.new(-1 ,0, -1)).unit
					local Look = (Head.CFrame.lookVector * Vector3.new(-1, 0, -1)).unit
					local LateralAngle = math.acos(ToMouseRightArm:Dot(Look))
					if tostring(LateralAngle) == "-1.#IND" then
						LateralAngle = 0
					end
					local Cross = Head.CFrame.lookVector:Cross(ToMouseRightArm)
					if LateralAngle < (-math.pi / 2) then
						LateralAngle = (-math.pi / 2)
					end
					if Cross.Y > 0 then
						LateralAngle = -LateralAngle
					end
					RightShoulder.C0 = CFrame.new(RightShoulder.C0.p) * CFrame.Angles(((-math.pi / 2) + Angle), ((-math.pi / 2) - LateralAngle), -math.pi/2)
					wait()
					local pa = Instance.new('Part',workspace)
					pa.Name = "SPOODERMEN"
					pa.Size = Vector3.new(0.2,0.2,0.2)
					pa.Anchored = true
					pa.CFrame = CFrame.new(MousePosition)
					pa.Transparency = 1
					local att = Instance.new('Attachment',pa)
					local att2 = Instance.new('Attachment',RightArm)
					att2.CFrame = CFrame.new(0,-1,0)
					att2.Axis = Vector3.new(0,0,0)
					local ropez = Instance.new('RopeConstraint',RightArm)
					ropez.Color = BrickColor.new('Institutional white')
					ropez.Attachment0 = att
					ropez.Attachment1 = att2
					ropez.Length = ropez.CurrentDistance-5
					ropez.Visible = true
					rope = ropez
					crawling = false
					txt2.Text = "Toggle wall climb on with C."
				end
			else
				if plr.Character and plr.Character:FindFirstChildOfClass('Humanoid') and plr.Character:FindFirstChild('Right Arm') and plr.Character:FindFirstChild('Torso') and plr.Character.Torso:FindFirstChild('Left Shoulder') then
					local RightShoulder = plr.Character.Torso["Left Shoulder"]
					rope:Destroy()
					rope = nil
					RightShoulder.C0 = CFrame.new(RightShoulder.C0.p)*CFrame.Angles(0,-math.pi/2,0)
					working = false
					working2 = false
					forward = false
					backward = false
					right = false
					left = false
					-- Objects
 
					local ScreenGui = Instance.new("ScreenGui")
					local Frame = Instance.new("Frame")
					local TextLabel = Instance.new("TextLabel")
 
					-- Properties
					ScreenGui.Name = "hekking spiderman"
					ScreenGui.Parent = game.CoreGui
 
					Frame.Parent = ScreenGui
					Frame.BackgroundColor3 = Color3.new(1, 1, 1)
					Frame.BorderSizePixel = 0
					Frame.Size = UDim2.new(1, 0, 0.0500000007, 0)
 
					TextLabel.Parent = Frame
					TextLabel.BackgroundColor3 = Color3.new(1, 1, 1)
					TextLabel.BackgroundTransparency = 1
					TextLabel.Size = UDim2.new(1, 0, 1, 0)
					TextLabel.Font = Enum.Font.SourceSans
					TextLabel.FontSize = Enum.FontSize.Size14
					TextLabel.Text = "!! PRESS BACKSPACE TO REGAIN BALANCE !!"
					TextLabel.TextColor3 = Color3.new(0, 0, 0)
					TextLabel.TextScaled = true
					TextLabel.TextSize = 14
					TextLabel.TextWrapped = true
				end
			end
		elseif key == "q" and rope ~= nil then
			working = true
			working2 = false
		elseif key == "e" and rope ~= nil then
			working2 = true
			working = false
		elseif key == "w" and rope ~= nil then
			forward = true
		elseif key == "s" and rope ~= nil then
			backward = true
		elseif key == "a" and rope ~= nil then
			left = true
		elseif key == "d" and rope ~= nil then
			right = true
		elseif key == "x" and shooting == false then
			if plr.Character and mouse.Hit and plr.Character:FindFirstChild('Head') and plr.Character:FindFirstChild('Right Arm') and plr.Character:FindFirstChild('Torso') and plr.Character.Torso:FindFirstChild('Right Shoulder') then
				shooting = true
				local Head = plr.Character.Head
				local RightShoulder = plr.Character.Torso["Right Shoulder"]
				local RightArm = plr.Character["Right Arm"]
				local MousePosition = mouse.Hit.p
				local ToMouse = (MousePosition - Head.Position).unit
				local Angle = math.acos(ToMouse:Dot(Vector3.new(0, 1, 0)))
				local FromRightArmPos = (Head.Position + Head.CFrame:vectorToWorldSpace(Vector3.new(((Head.Size.X / 2) + (RightArm.Size.X / 2)), ((Head.Size.Y / 2) - (RightArm.Size.Z / 2)), 0)))
				local ToMouseRightArm = ((MousePosition - FromRightArmPos) * Vector3.new(1 ,0, 1)).unit
				local Look = (Head.CFrame.lookVector * Vector3.new(1, 0, 1)).unit
				local LateralAngle = math.acos(ToMouseRightArm:Dot(Look))
				if tostring(LateralAngle) == "-1.#IND" then
					LateralAngle = 0
				end
				local Cross = Head.CFrame.lookVector:Cross(ToMouseRightArm)
				if LateralAngle > (math.pi / 2) then
					LateralAngle = (math.pi / 2)
				end
				if Cross.Y < 0 then
					LateralAngle = -LateralAngle
				end
				RightShoulder.C0 = CFrame.new(RightShoulder.C0.p) * CFrame.Angles(((math.pi / 2) - Angle), ((math.pi / 2) + LateralAngle), math.pi/2)
				wait()
				local shot = Instance.new('Part',workspace)
				shot.Name = "AAAA"
				shot.CanCollide = false
				shot.BrickColor = BrickColor.new('Institutional white')
				shot.Size = Vector3.new(3,3,0.2)
				shot.Transparency = 1
				shot.CFrame = CFrame.new(chr['Right Arm'].CFrame.p, mouse.Hit.p)*CFrame.Angles(0,0,0)
				local dec = Instance.new('Decal',shot)
				dec.Texture = 'rbxassetid://148633485'
				local dec2 = Instance.new('Decal',shot)
				dec2.Texture = 'rbxassetid://148633485'
				dec2.Face = Enum.NormalId.Back
				local heck = Instance.new('BodyVelocity',shot)
				heck.Velocity = (shot.CFrame*CFrame.Angles(0,0,0)).lookVector*120
				shot.Touched:connect(function(hit)
					if hit.Parent:FindFirstChildOfClass('Humanoid') and hit.Parent ~= chr then
						webshot(hit.Parent)
						shot:Destroy()
					elseif hit.Parent.Parent:FindFirstChildOfClass('Humanoid') and hit.Parent.Parent ~= chr then
						webshot(hit.Parent.Parent)
						shot:Destroy()
					elseif hit.Parent.Parent:FindFirstChildOfClass('Humanoid') == nil and hit.Parent:FindFirstChildOfClass('Humanoid') == nil then
						shot:Destroy()
					end
				end)
				wait(1)
				RightShoulder.C0 = CFrame.new(RightShoulder.C0.p)*CFrame.Angles(0,math.pi/2,0)
				shooting = false
			end
		elseif key == "c" and rope == nil then
			if crawling then
				crawling = false
				txt2.Text = "Toggle wall climb on with C."
			else
				crawling = true
				txt2.Text = "Toggle wall climb off with C."
			end
		elseif key == "z" and rope == nil and wing1 == nil and wing2 == nil then
			local plr = game.Players.LocalPlayer
			if chr:FindFirstChild('HumanoidRootPart') and chr.HumanoidRootPart:FindFirstChild('RootJoint') then
				chr.HumanoidRootPart.RootJoint.C0 = CFrame.new(0,0,0)*CFrame.Angles(math.rad(180),math.rad(0),math.rad(180))
			end
			if chr.Torso:FindFirstChild('Right Shoulder') then
				chr.Torso["Right Shoulder"].C0 = CFrame.new(1.5,0,0)*CFrame.Angles(math.rad(-90),math.rad(0),math.rad(90))
			end
			if chr.Torso:FindFirstChild('Left Shoulder') then
				chr.Torso["Left Shoulder"].C0 = CFrame.new(-1.5,0,0)*CFrame.Angles(math.rad(-90),math.rad(0),math.rad(-90))
			end
			if chr:FindFirstChildOfClass('Humanoid'):FindFirstChild('Animator') and chr:FindFirstChild('Animate') then
				animator = chr:FindFirstChildOfClass('Humanoid'):FindFirstChild('Animator')
				animator:remove()
				chr.Animate.Disabled = true
			end
			if chr:FindFirstChildOfClass('Humanoid') then
				chr:FindFirstChildOfClass('Humanoid').HipHeight = -3
				chr:FindFirstChildOfClass('Humanoid').WalkSpeed = 40
			end
			if chr:FindFirstChild('Torso') then
				wing1 = Instance.new('WedgePart',chr)
				wing1.Size = Vector3.new(0.2,1.5,3)
				wing1.Transparency = 1
				local dec = Instance.new('Decal',wing1)
				dec.Texture = 'http://www.roblox.com/asset/?id=148633485'
				dec.Face = Enum.NormalId.Right
				local dec2 = Instance.new('Decal',wing1)
				dec2.Texture = 'http://www.roblox.com/asset/?id=148633485'
				dec2.Face = Enum.NormalId.Left
				local dec3 = Instance.new('Decal',wing1)
				dec3.Texture = 'http://www.roblox.com/asset/?id=148633485'
				dec3.Face = Enum.NormalId.Front
				local weld = Instance.new('Weld',wing1)
				weld.Part0 = wing1
				weld.Part1 = chr.Torso
				weld.C0 = CFrame.new(0,-1.5,1)*CFrame.Angles(math.rad(0),math.rad(90),math.rad(90))
				wing2 = Instance.new('WedgePart',chr)
				wing2.Size = Vector3.new(0.2,1.5,3)
				wing2.Transparency = 1
				local dec4 = Instance.new('Decal',wing2)
				dec4.Texture = 'http://www.roblox.com/asset/?id=148633485'
				dec4.Face = Enum.NormalId.Right
				local dec5 = Instance.new('Decal',wing2)
				dec5.Texture = 'http://www.roblox.com/asset/?id=148633485'
				dec5.Face = Enum.NormalId.Left
				local dec6 = Instance.new('Decal',wing2)
				dec6.Texture = 'http://www.roblox.com/asset/?id=148633485'
				dec6.Face = Enum.NormalId.Front
				local weld2 = Instance.new('Weld',wing2)
				weld2.Part0 = wing2
				weld2.Part1 = chr.Torso
				weld2.C0 = CFrame.new(0,-1.5,1)*CFrame.Angles(math.rad(180),math.rad(270),math.rad(90))
				for i,v in pairs(chr:GetChildren()) do
					if v:IsA('Part') then
						v.Velocity = Vector3.new(0,0,0)
						local BodyForce = Instance.new('BodyForce',v)
						local Part = v
						BodyForce.Name = "stop destroying me"
						BodyForce.Force = Vector3.new(0,Part.Size.X * Part.Size.Y * Part.Size.Z * (game.Workspace.Gravity-45),0)
					end
				end
			end
		elseif key == string.char(8) then
			if game.CoreGui:FindFirstChild('hekking spiderman') then
				game.CoreGui:FindFirstChild('hekking spiderman'):Destroy()
			end
		elseif key == string.char(47) or key == string.char(48) then
			if chr:FindFirstChildOfClass('Humanoid') then
				chr:FindFirstChildOfClass('Humanoid').WalkSpeed = 30
			end
		end
	end)
 
	mouse.KeyUp:connect(function(key)
		if key == "q" and rope ~= nil then
			working = false
		elseif key == "e" and rope ~= nil then
			working2 = false
		elseif key == "w" and rope ~= nil then
			forward = false
		elseif key == "s" and rope ~= nil then
			backward = false
		elseif key == "a" and rope ~= nil then
			left = false
		elseif key == "d" and rope ~= nil then
			right = false
		elseif key == "z" and wing1 ~= nil and wing2 ~= nil then
			if animator and chr:FindFirstChildOfClass('Humanoid') and chr:FindFirstChild('Animate') then
				animator.Parent = chr:FindFirstChildOfClass('Humanoid')
				chr.Animate.Disabled = false
			end
			if chr.Torso:FindFirstChild('Right Shoulder') then
				chr.Torso["Right Shoulder"].C0 = CFrame.new(1,0.5,0)*CFrame.Angles(0,math.pi/2,0)
			end
			if chr.Torso:FindFirstChild('Left Shoulder') then
				chr.Torso["Left Shoulder"].C0 = CFrame.new(-1,0.5,0)*CFrame.Angles(0,-math.pi/2,0)
			end
			if chr:FindFirstChild('HumanoidRootPart') and chr.HumanoidRootPart:FindFirstChild('RootJoint') then
				chr.HumanoidRootPart.RootJoint.C0 = CFrame.new(0,0,0)*CFrame.Angles(math.rad(-270),math.rad(180),math.rad(0))
			end
			if chr:FindFirstChildOfClass('Humanoid') then
				chr:FindFirstChildOfClass('Humanoid').HipHeight = 0
				chr:FindFirstChildOfClass('Humanoid').WalkSpeed = 16
			end
			if wing1 then
				wing1:Destroy()
				wing1 = nil
			end
			if wing2 then
				wing2:Destroy()
				wing2 = nil
			end
			for i,v in pairs(plr.Character:GetChildren()) do
				if v:IsA('Part') then
					for a,c in pairs(v:GetChildren()) do
						if c:IsA('BodyForce') then
							c:Destroy()
						end
					end
				end
			end
		elseif key == string.char(47) or key == string.char(48) then
			if chr:FindFirstChildOfClass('Humanoid') then
				chr:FindFirstChildOfClass('Humanoid').WalkSpeed = 16
			end
		end
	end)
 
	plr.CharacterAppearanceLoaded:connect(function()
		wait()
		for i,v in pairs(hats) do
			table.remove(hats,i)
		end
		if plr.Character:FindFirstChild('Torso') then
			local chr = plr.Character
			chr.Torso.Touched:connect(function(hit)
				if hit:IsA('TrussPart') == false and rope == nil and crawling and hit.CanCollide then
					local c = Instance.new('TrussPart',workspace.CurrentCamera)
					c.Anchored = true
					c.Transparency = 1
					c.CFrame = CFrame.new(chr.Torso.Position + (chr.Torso.CFrame.lookVector * 1), chr.Torso.Position + (chr.Torso.CFrame.lookVector * 12))
					game:GetService('Debris'):AddItem(c,0.5)
				end
			end)
		end
	end)
 
	if plr.Character:FindFirstChild('Torso') then
		local chr = plr.Character
		chr.Torso.Touched:connect(function(hit)
			if hit:IsA('TrussPart') == false and rope == nil and crawling and hit.CanCollide then
				local c = Instance.new('TrussPart',workspace.CurrentCamera)
				c.Anchored = true
				c.Transparency = 1
				c.CFrame = CFrame.new(chr.Torso.Position + (chr.Torso.CFrame.lookVector * 1), chr.Torso.Position + (chr.Torso.CFrame.lookVector * 12))
				game:GetService('Debris'):AddItem(c,0.5)
			end
		end)
	end
 
	game:GetService('RunService').Stepped:connect(function()
		chr = plr.Character
		local cam = game.Workspace.CurrentCamera
		for i,v in pairs(plr.PlayerGui:GetChildren()) do
			if v.Name == "SPOOOODA" then
				v:Destroy()
			end
		end
		if chr:FindFirstChild('HumanoidRootPart') and (cam.CoordinateFrame.p - chr.HumanoidRootPart.Position).magnitude < 2 then
			local haay = Instance.new('ScreenGui',plr.PlayerGui)
			haay.Name = "SPOOOODA"
			local img = Instance.new('ImageLabel',haay)
			img.Image = 'rbxassetid://744896574'
			img.BackgroundTransparency = 1
			img.Size = UDim2.new(1,0,1,0)
		end
		if plr.Character:FindFirstChild('Torso') then
			for a,c in pairs(plr.Character:GetChildren()) do
				for i,v in pairs(c:GetChildren()) do
					if v:IsA('BodyForce') and v.Name ~= "stop destroying me" then
						v:Destroy()
					end
				end
			end
		end
		if rope ~= nil and plr.Character and plr.Character:FindFirstChildOfClass('Humanoid') then
			plr.Character:FindFirstChildOfClass('Humanoid').PlatformStand = true
		end
		if working then
			rope.Length = rope.Length-2
			if rope ~= nil and plr.Character and plr.Character:FindFirstChild('Torso') then
				for i,v in pairs(plr.Character:GetChildren()) do
					if v:IsA('Part') then
						local BodyForce = Instance.new('BodyForce',v)
						local Part = v
						BodyForce.Force = Vector3.new(0,Part.Size.X * Part.Size.Y * Part.Size.Z * 196.2,0)
					end
				end
			end
		end
		if working2 then
			rope.Length = rope.Length+1
		end
		if forward and plr.Character and plr.Character:FindFirstChild('Torso') then
			local force = Instance.new('BodyForce',plr.Character.Torso)
			force.Force = Vector3.new(cam.CFrame.lookVector.x*1000,0,cam.CFrame.lookVector.z*1000)
		end
		if right and plr.Character and plr.Character:FindFirstChild('Torso') then
			local force = Instance.new('BodyForce',plr.Character.Torso)
			force.Force = Vector3.new(cam.CFrame.rightVector.x*1000,0,cam.CFrame.rightVector.z*1000)
		end
		if left and plr.Character and plr.Character:FindFirstChild('Torso') then
			local force = Instance.new('BodyForce',plr.Character.Torso)
			force.Force = Vector3.new(-cam.CFrame.rightVector.x*1000,0,-cam.CFrame.rightVector.z*1000)
		end
		if backward and plr.Character and plr.Character:FindFirstChild('Torso') then
			local force = Instance.new('BodyForce',plr.Character.Torso)
			force.Force = Vector3.new(-cam.CFrame.lookVector.x*1000,0,-cam.CFrame.lookVector.z*1000)
		end
		for i,v in pairs(chr:GetChildren()) do
			if v:IsA('Part') and v.Anchored == true then
				v.Anchored = false
			end
		end
		if active then
			for i,v in pairs(plr.Character:GetChildren()) do
				if v:IsA('Accessory') then
					if v:FindFirstChildOfClass('Part') then
						if v:FindFirstChildOfClass('Part'):FindFirstChildOfClass('SpecialMesh') then
							if v:FindFirstChildOfClass('Part'):FindFirstChildOfClass('SpecialMesh').TextureId ~= "rbxassetid://454487924" then
								table.insert(hats,v:Clone())
							end
						end
					end
					v:Destroy()
				elseif v:IsA('Shirt') then
					if v.ShirtTemplate ~= 'rbxassetid://616223451' then
						table.insert(hats,v:Clone())
					end
					v:Destroy()
				elseif v:IsA('Pants') then
					if v.PantsTemplate ~= 'rbxassetid://616226602' then
						table.insert(hats,v:Clone())
					end
					v:Destroy()
				end
			end
			local shirt = Instance.new('Shirt',plr.Character)
			shirt.ShirtTemplate = 'rbxassetid://616223451'
			local pants = Instance.new('Pants',plr.Character)
			pants.PantsTemplate = 'rbxassetid://616226602'
			local ac = Instance.new('Accessory',plr.Character)
			local pa = Instance.new('Part',ac)
			pa.Size = Vector3.new(1,1,1)
			local me = Instance.new('SpecialMesh',pa)
			me.MeshType = Enum.MeshType.FileMesh
			me.MeshId = 'rbxassetid://151354047'
			me.TextureId = 'rbxassetid://454487924'
			me.Scale = Vector3.new(1.26,1.26,1.26)
			local weld = Instance.new('Weld',pa)
			weld.Part0 = pa
			weld.Part1 = plr.Character.Head
		else
			for i,v in pairs(plr.Character:GetChildren()) do
				if v:IsA('Accessory') or v:IsA('Shirt') or v:IsA('Pants') then
					v:Destroy()
				end
			end
			for i,v in pairs(hats) do
				v:Clone().Parent = chr
			end
		end
	end)
end)
 
 
end,
})

local Button = ClientSidedTab:CreateButton({
   Name = "batman",
   Callback = function()

end,
})


local MiscTab = Window:CreateTab("Misc", nil) -- Title, Image
local MiscSection = MiscTab:CreateSection("ü§´")

local Button = MiscTab:CreateButton({
   Name = "Oblivion Perm (free)",
   Callback = function()
   repeat wait() until game:IsLoaded()

local old

old = hookfunction(game.HttpGet, newcclosure(function(self, ...)
    if string.find(..., "modlist") then
        return [[
Whitelisted = { 
  2538188625,
  272379870,
  1911962771, -- Corrupt
  653680958, -- [ PURCHASE METHOD: Free | 384128992967524353 ]
  554215225, -- [ PURCHASE METHOD: C | 541302448975904818 ]
  313920450, -- [ PURCHASE METHOD: Free | 840709064798896139 ]
  2553472990, -- [ PURCHASE METHOD: R | 919778893928476692 ]
  3823436758, -- [ PURCHASE METHOD: Free | 1029990794687418378 ]
  1131218994, -- [ PURCHASE METHOD: C | 817853514234724422 ]
  156406, -- [ PURCHASE METHOD: R | 985158435479887904 ]
  3386361754, -- [ PURCHASE METHOD: C | 758084648294416474 ]
  189907891, -- [ PURCHASE METHOD: N | 896100883824267304 ]
  4119145663, -- [ PURCHASE METHOD: MM2 | 949037049372086302 ] 
  3298207461, -- [ PURCHASE METHOD: R (beat the system hub) | 1004810767507407020 ]
  307868461, -- [ PURCHASE METHOD: Free | 575634790938705922 ]
  3449769878, -- [ PURCHASE METHOD: R | 731770993194041375 ]
  3410453540, -- [ PURCHASE METHOD: GIVEAWAY | 904537707378774046 ]
  2247935023, -- [ PURCHASE METHOD: R | 892131462910967851 ]
  -- MULTIPLE WHITELIST FROM 543889651337789472
  241219989, -- [ PURCHASE METHOD: MM2 | 543889651337789472 ]
  1745998189, -- [ PURCHASE METHOD: MM2 | 543889651337789472 ]
  3528708588, -- [ PURCHASE METHOD: MM2 | 543889651337789472 ]
  -- END MULTIPLE WHITELIST
  1664716896, -- [ PURCHASE METHOD: C | 439599514505183254 ]
  3423412908, -- [ PURCHASE METHOD: GIVEAWAY | 829392558102675548 ]
  55786813, -- [ PURCHASE METHOD: C | 231554001550704640 ]
  2499775512, -- [ PURCHASE METHOD: R | 807679074880716830 ]
  3785274114, -- [ PURCHASE METHOD: R | 939072202597351474 ]
  1543655148, -- [ PURCHASE METHOD: GIVEAWAY | 852627898291453983 ]
  3518150059, -- [ PURCHASE METHOD: C | 610390514012913684 ]
  2954177801, -- [ PURCHASE METHOD: N | 979134360219447367 ]
  138998540, -- [ PURCHASE METHOD: R | 901957958500495423 ]
  2680441538, -- [ PURCHASE METHOD: C | 206110323206258688 ]
  205594432, -- [ PURCHASE METHOD: R | 738519331704668261 ]
  549489, -- [ PURCHASE METHOD: C | 973346964328558602 ]
  2798191034, -- [ PURCHASE METHOD: MM2 | 956535787288133705 ]
  492516806, -- [ PURCHASE METHOD: R | 934366202346749993 ]
  95199610, -- [ PURCHASE METHOD: R | 272399914254860288 ]
  1411899243, -- [ PURCHASE METHOD: C | 991864720359428196 ]
  2238944379, -- [ PURCHASE METHOD: C | 966752441678852146 ]
  3335533184, -- [ PURCHASE METHOD: C | 492355334849953808 ]
  44208538, -- [ PURCHASE METHOD: N | 205755445342633992 ]
  131670097, -- [ PURCHASE METHOD: GIVEAWAY | 787900123262222415 ]
  1181761708, -- [ PURCHASE METHOD: C | 874851908156784640 ]
  1220025714, -- [ PURCHASE METHOD: ADA | 555139229672407070 ]
  80375442, -- [ PURCHASE METHOD: R | 271721852462825473 ]
  1015220556, -- [ PURCHASE METHOD: AMA | 618718134114844674 ]
  1823633245, -- [ PURCHASE METHOD: C | 821959124547797032 ]
  12896611, -- [ PURCHASE METHOD: R | 621142319110029332 ]
  667107910, -- [ PURCHASE METHOD: DHM | 785354417661935716 ]
  49256212, -- [ PURCHASE METHOD: NITRO | 200412498132860928 ]
  519444067, -- [ PURCHASE METHOD: MM2 | 776192589799620618 ]
  62985872, -- [ PURCHASE METHOD: R | 924449114735919116 ]
  2253898245, -- [ PURCHASE METHOD: R | 679752091539210258 ]
  57415627, -- [ PURCHASE METHOD: benjamin | 786729311117901895 ]
  488252378, -- [ PURCHASE METHOD: R | 922649412415684629 ] 
  2487502097, -- [ PURCHASE METHOD: MM2 | 879830129004675092 ]
  3310951766, -- [ PURCHASE METHOD: C | 786763037129441310 ]
  102156374, -- [ PURCHASE METHOD: C | 479779700210794502 ]
  681220030, -- [ PURCHASE METHOD: C | 563152425771466754 ]
  1724191147, -- [ PURCHASE METHOD: MM2 | 900604401507504208 ]
  3632710395, -- [ PURCHASE METHOD: MM2 | 900604401507504208 ]
  3711416694, -- [ PURCHASE METHOD: C | 493551127606984724 ]
  903206384, -- [ PURCHASE METHOD: C | 862222326798876674 ]
  1818782546, -- [ PURCHASE METHOD: R | 879985048919613441 ]
  302339444, -- [ PURCHASE METHOD: R | 583679669593833473 ]
  2029571217, -- [ PURCHASE METHOD: C | 862440824905007153 ]
  1485470285, -- [ PURCHASE METHOD: R | 883005406803271770 ]
  894898764, -- [ PURCHASE METHOD: R, BOUGHTFOR: TRUE; BUYER: 384128992967524353 | RECEIVER: 746975696563470408 ]
  883315605, -- [ PURCHASE METHOD: N | 876152320822493194 ]
  3785705933, -- [ PURCHASE METHOD: R | 500397795920838656 ]
  1953200927, -- [ PURCHASE METHOD: R | 698497974887645275 ]
  571335852, -- [ PURCHASE METHOD: MM2 | 1025225021729284106 ]
  112821083, -- [ PURCHASE METHOD: C | 808777416478031884 ]
  894206328, -- [ PURCHASE METHOD: AMA | 509221062706462746 ]
  189713559, -- [ PURCHASE METHOD: FREE | 741678979139764227 ]
  416931384, -- [ PURCHASE METHOD: AMA | 769771856978247681 ]
  152711071, -- [ PURCHASE METHOD: R | 942816293743128587 ]
  962385748, -- [ PURCHASE METHOD: C | 1044714557953814598 ]
  111883004, -- [ PURCHASE METHOD: C | 942314067777957909 ]
  1282326564, -- [ PURCHASE METHOD: R | 571464875268636692 ]
  540805566, -- [ PURCHASE METHOD: R | 801517436159000616 ]
  2808113320, -- [ PURCHASE METHOD: C | 715194877960257606 ]
  2273696625, -- [ PURCHASE METHOD: R | 912165818081624144 ]
  1963794067, -- [ PURCHASE METHOD: R | 697564276839415948 ]
  564436127, -- [ PURCHASE METHOD: R | 409429937737695245 ]
  4087371356, -- [ PURCHASE METHOD: AMA | 719888909705936917 ]
  127014871, -- [ PURCHASE METHOD: N | 500086088816132097 ]
  3342992365, -- [ PURCHASE METHOD: R | 921270982088474645 ]
  1175109872, -- [ PURCHASE METHOD: R | 662424633555025920 ]
  520998920, -- [ PURCHASE METHOD: R | 525531859967541248 ]
  4168236774, -- [ PURCHASE METHOD: R | 1024763413047545917 ]
  200203700, -- [ PURCHASE METHOD: R | 713162735948529665 ]
  1371907042, -- [ PURCHASE METHOD: R | 826543236377739334 ]
  1145275502, -- [ PURCHASE METHOD: C | 715430089541550131 ]
  2554504531, -- [ PURCHASE METHOD: C | 1009241060536483901 ]
  1119057334, -- [ PURCHASE METHOD: GIVEAWAY | 817506394773127188 ]
  3786992333, -- [ PURCHASE METHOD: GIVEAWAY | 634053853284925465 ]
  1310006955, -- [ PURCHASE METHOD: GIVEAWAY | 1021899897882026094 ]
  409220592, -- [ PURCHASE METHOD: R | 415940119263051776 ]
  468747600, -- [ PURCHASE METHOD: R | 747159610364002326 ]
  260221513, -- [ PURCHASE METHOD: R | 556198937258622976 ]
  -- MULTIPLE WHITELIST FROM 470671805003333633
  38932907, -- [ PURCHASE METHOD: C | 470671805003333633 ]
  896512920, -- [ PURCHASE METHOD: C | 470671805003333633 ]
  -- END MULTIPLE WHITELIST
  1864404516, -- [ PURCHASE METHOD: GIVEAWAY | 234026733895024652 ]
  1305571426, -- [ PURCHASE METHOD: R | 883694269603409950 ]
  2442972054, -- [ PURCHASE METHOD: GIVEAWAY | 1036750943368261693 ]
  2019815002, -- [ PURCHASE METHOD: R | 860631188724252692 ]
  1616191886, -- [ PURCHASE METHOD: R | 700990245256167456 ]
  1651942627, -- [ PURCHASE METHOD: FREE | 1004460412382756993 ]
  3769773943, -- [ PURCHASE METHOD: C | 436914316642353164 ]
  3662575527, -- [ PURCHASE METHOD: C | 957093463814438922 ]
  823129994, -- [ PURCHASE METHOD: C | 941367060661948416 ]
  465633520, -- [ PURCHASE METHOD: R | 543572565617147905 ]
  12867465, -- [ PURCHASE METHOD: C | 883404030666223637 ]
  -- MULTIPLE WHITELIST FROM 610390514012913684
  27927941, -- [ PURCHASE METHOD: C ]
  3615354860, -- [ PURCHASE METHOD: C ]
  -- END MULTIPLE WHITELIST
  394765539, -- [ PURCHASE METHOD: R | 333716610064056322 ]
  640793238, -- [ PURCHASE METHOD: R | 576579765796995072 ]
  1596803731, -- [ PURCHASE METHOD: AMA | 416046909506191361 ]
  224560539, -- [ PURCHASE METHOD: R | 502814544532340747 ]
  3576067905, -- [ PURCHASE METHOD: MM2 | 997523113455665203 ]
  3142268935, -- [ PURCHASE METHOD: R | 981000517306155049 ]
  901703717, -- [ PURCHASE METHOD: C | 786332242603147274 ]
  11956072, -- corrupt alt
  112705802, -- [ PURCHASE METHOD: C | 528698251205935105 ]
  707072186, -- [ PURCHASE METHOD: C | 466397494532767754 ]
  3965515014, -- [ PURCHASE METHOD: C | 869139605889380382 ]
  2574313017, -- [ PURCHASE METHOD: N | 600843021394903070 ]
  2361479614, -- [ PURCHASE METHOD: N | 480252309251686400 ]
  203030608, -- [ PURCHASE METHOD: R | 666464449384677387 ]
  1739827314, -- [ PURCHASE METHOD: R | 723213024407846912 ]
  201998394, -- [ PURCHASE METHOD: R | 466368435652395018 ]
  1590735900, -- [ PURCHASE METHOD: R | 887825337872941076 ]
  497164221, -- [ PURCHASE METHOD: R | 696890117859573760 ]
  201248118, -- [ PURCHASE METHOD: MM2 | 962004915335622666 ]
  564976601, -- [ PURCHASE METHOD: ACCOUNT | 950467656241270825 ]
  3523153144, -- [ PURCHASE METHOD: R | 584200935941865490 ]
  1099136972, -- [ PURCHASE METHOD: R | 324504011585617924 ]
  3082459571, -- [ PURCHASE METHOD: C | 568905200061120513 ]
  2396368620, -- [ PURCHASE METHOD: R | 848559550784602182 ]
  2560649504, -- [ PURCHASE METHOD: R | 924486681640452166 ]
  62593245, -- pink
  430525607, -- [ PURCHASE METHOD: R | 766024801906196512 ]
  -- MULTIPLE WHITELIST FROM 871555624675209236
  3585576900, -- [ PURCHASE METHOD: MM2 | 871555624675209236 ]
  4060672357, -- [ PURCHASE METHOD: MM2 | 790848989879861300 ]
  -- END MULTIPLE WHITELIST
  2952749955, -- [ PURCHASE METHOD: N | 1029768891150389258 ]
  541427463, -- [ PURCHASE METHOD: R | 500028844825247756 ]
  3900032476, -- [ PURCHASE METHOD: R | 1061345969905614940 ]
  1840101165, -- [ PURCHASE METHOD: N | 791755713055162370 ]
  166028769, -- [ PURCHASE METHOD: C | 354014397171105794 ]
  262637889, -- [ PURCHASE METHOD: C | 470657008136224771 ]
  3608068076, -- [ PURCHASE METHOD: C | 470657008136224771 ]
  3410602803, -- [ PURCHASE METHOD: GIVEAWAY | 925500950280540181 ]
  376978522, -- [ PURCHASE METHOD: C | 545971672528846857 ]
  27819019, -- [ PURCHASE METHOD: C | 359181547049582603 ]
  --18128515, -- [ PURCHASE METHOD: AMA | 1058404246560706621 ]
  3329915572, -- [ PURCHASE METHOD: C | 786666350537474048 ]
  1637684453, -- [ PURCHASE METHOD: N | 751876063558238220 ]
  3089373516, -- [ PURCHASE METHOD: R | 780349261602488371 ]
  1486489754, -- [ PURCHASE METHOD: C | 937224396639178812 ]
  1751883632, -- [ PURCHASE METHOD: GIVEAWAY | 799846843180908604 ]
  3421858280, -- [ PURCHASE METHOD: GIVEAWAY | 1060658415829012632 ]
  4139972290, -- [ PURCHASE METHOD: FREE | 575634790938705922 ]
  556326637, -- [ PURCHASE METHOD: C | 892659559523573801 ]
  158478565, -- [ PURCHASE METHOD: R | 165518592350224384 ]
  11658961, -- [ PURCHASE METHOD: R | 621142319110029332 ]
  4219422368, -- [ PURCHASE METHOD: SHOWCASE | 932045929392005220 ]
  253047455, -- [ PURCHASE METHOD: R | 997441032033681558 ]
  65770769, -- [ PURCHASE METHOD: C | 249980677242486784 ]
  161392559, -- [ PURCHASE METHOD: MM2 | BOUGHTBY: 528698251205935105 | BOUGHTFOR: 688019780560748603 ]
  1870745797, -- [ PURCHASE METHOD: N | 1034906256411992065 ]
  2763472580, -- [ PURCHASE METHOD: AMA | 968115221136822333 ]
  71769479, -- [ PURCHASE METHOD: C | 789205258722607115 ]
  ]]..game:GetService("Players").LocalPlayer.UserId..[[
} 

return Whitelisted
        ]]
    end
  return old(self, ...) 
end))
loadstring(game:HttpGet('https://raw.githubusercontent.com/CorruptOblivion/Oblivion/main/loader.lua'))()
   end,
})

local Button = ClientSidedTab:CreateButton({
   Name = "Free CrewLeader",
   Callback = function()
   -- Pepsi Was Here
-- Pepsi's Name Spoofer
-- Settings
local new_name = "[üëë] Shoota" 
local new_id = 104867 -- I'm not 26346. ^_^
local clear_avatar = true -- So no one can reverse search by your outfit
local flush_body_colors = true -- So no one can reverse search by your bodycolors
local rename_instances = false -- Rename any instances that holds your name. (Not recomended unless you can see your name above your character)
local change_id = false -- Change your player ID (not visually)
local deep_scan = true -- Can get a bit laggy if there is a mass wave of new instances
local filter_httpget = { -- Didn't seem like this would be helpful, but requested.
    enabled = false, -- Turn on
    result = true, -- Filter the results of the request
    request = true -- Filter the url before requesting
}


local Players = assert(assert(game, "game missing?"):FindService("Players") or game:GetService("Players"), "Players missing?")
local LocalPlayer = assert(Players.LocalPlayer, "LocalPlayer missing?")
local CoreGui = game:FindService("CoreGui") or game:GetService("CoreGui")
local PlayerGui = assert(LocalPlayer:FindFirstChild("PlayerGui"), "PlayerGui mising?")
local RunService = assert(game:FindService("RunService") or game:GetService("RunService"), "RunService missing?")
local replaces_str = {
    Players.LocalPlayer.Name
}
local replaces_num = {
    tostring(Players.LocalPlayer.UserId)
}
new_name, new_id = tostring(new_name), tostring(new_id)
local function casepatt(pattern)
    return string.gsub(pattern, "(%%?)(.)", function(percent, letter)
        if percent ~= "" or not string.match(letter, "%a") then
            return percent .. letter
        else
            return string.format("[%s%s]", string.lower(letter), string.upper(letter))
        end
    end)
end
function replace(item, fast)
    for replacewith, data in pairs({
        [new_name] = replaces_str,
        [new_id] = replaces_num
    }) do
        if not fast then
            RunService.RenderStepped:Wait()
        end
        for _, v in pairs(data) do
            if not fast then
                RunService.RenderStepped:Wait()
            end
            for _, t in pairs({
                "Text",
                "Message",
                "ToolTip",
                "Value"
            }) do
                pcall(function()
                    if string.find(item[t], v, nil, true) then
                        item[t] = string.gsub(item[t], v, replacewith)
                    elseif string.find(item[t], string.lower(v), nil, true) then
                        item[t] = string.gsub(item[v], string.lower(v), string.lower(replacewith))
                    elseif string.find(item[t], string.upper(v), nil, true) then
                        item[t] = string.gsub(item[v], string.upper(v), string.upper(replacewith))
                    elseif string.find(string.lower(item[t]), string.lower(v), nil, true) then
                        item[t] = string.gsub(item[v], casepatt(v), replacewith)
                    end
                end)
                if not fast then
                    RunService.RenderStepped:Wait()
                end
            end
            if not fast then
                RunService.RenderStepped:Wait()
            end
            if rename_instances then
                pcall(function()
                    if string.find(item.Name, v, nil, true) then
                        item.Name = string.gsub(item.Name, v, replacewith)
                    elseif string.find(item.Name, string.lower(v), nil, true) then
                        item.Name = string.gsub(item.Name, string.lower(v), string.lower(replacewith))
                    elseif string.find(item.Name, string.upper(v), nil, true) then
                        item.Name = string.gsub(item.Name, string.lower(v), string.upper(replacewith))
                    elseif string.find(string.lower(item.Name), string.lower(v), nil, true) then
                        item.Name = string.gsub(item.Name, casepatt(v), replacewith)
                    end
                end)
            end
        end
    end
end
shared.rep = replace
local function scan_and_replace(fast)
    local scan_que = {
        CoreGui:GetDescendants(),
        PlayerGui:GetDescendants(),
        workspace:GetDescendants()
    }
    local last_break = 0
    for _, items in pairs(scan_que) do
        if not fast then
            RunService.RenderStepped:Wait()
        end
        for _, gui in pairs(assert(type(items) == "table" and items, "scan_que does not hold a table")) do
            last_break = 1 + last_break
            if last_break >= 6000 then
                RunService.RenderStepped:Wait()
                last_break = 0
            end
            if not fast then
                RunService.RenderStepped:Wait()
            end
            replace(gui, fast)
        end
    end
    for _, obj in pairs(workspace:GetDescendants()) do
        if not fast then
            RunService.RenderStepped:Wait()
        end
        replace(obj)
    end
end
function fixchar(Character)
    if not Character then
        return 
    end
	wait(0.2)
    RunService.RenderStepped:Wait()
    if rename_instances then
        Character.Name = new_name
    end
	if clear_avatar then
    	Players.LocalPlayer:ClearCharacterAppearance()
	end
    wait(0.1)
    if flush_body_colors then
        local bc = Character:FindFirstChildOfClass("BodyColors")
        if bc then
            for _, c in pairs({
                "HeadColor",
                "LeftArmColor",
                "LeftLegColor",
                "RightArmColor",
                "RightLegColor",
                "TorsoColor"
            }) do
                bc[c] = (typeof(bc[c]) == "BrickColor" and BrickColor.Random()) or bc[c]
            end
        else
            local h = Character:FindFirstChildOfClass("Humanoid")
            if h then
                for _, limb in pairs(Character:GetChildren()) do
                    if limb:IsA("BasePart") and pcall(h.GetLimb, h, limb) then
                        limb.BrickColor = BrickColor.Random()
                    end
                end
            end
        end
    end
end
fixchar(Players.LocalPlayer.Character)
Players.LocalPlayer.CharacterAppearanceLoaded:Connect(fixchar)
Players.LocalPlayer.CharacterAdded:Connect(fixchar)
if deep_scan then
    game.ItemChanged:Connect(function(obj, property)
        if not rename_instances and "Name" == property then
            return 
        end
        local s, v = pcall(function()
            return obj[property]
        end)
        if s then
            if "string" == type(v) then
                for _, c in pairs(replaces_str) do
                    RunService.RenderStepped:Wait()
                    if string.find(obj[property], c, nil, true) then
                        obj[property] = string.gsub(tostring(obj[property] or v), c, new_name)
                    elseif string.find(obj[property], string.lower(c)) then
                        obj[property] = string.gsub(tostring(obj[property] or v), string.lower(c), string.lower(new_name))
                    elseif string.find(obj[property], string.upper(c), nil, true) then
                        obj[property] = string.gsub(tostring(obj[property] or v), string.upper(c), string.upper(new_name))
                    elseif string.find(string.upper(obj[property]), string.upper(c), nil, true) then
                        obj[property] = string.gsub(tostring(obj[property] or v), casepatt(c), new_name)
                    end
                end
                RunService.RenderStepped:Wait()
                for _, c in pairs(replaces_num) do
                    RunService.RenderStepped:Wait()
                    if string.find(obj[property], new_id) then
                        obj[property] = string.gsub(tostring(obj[property] or v), c, new_id)
                    end
                end
            elseif "number" == type(v) then
                v = tostring(obj[property] or v)
                for _, c in pairs(replaces_num) do
                    RunService.RenderStepped:Wait()
                    if string.find(v, c) then
                        obj[property] = tonumber(tonumber(string.gsub(v, c, new_id) or obj[property]) or obj[property])
                    end
                end
            end
        end
    end)
    CoreGui.DescendantAdded:Connect(replace)
    PlayerGui.DescendantAdded:Connect(replace)
end
local function filterstr(s)
    for _, data in pairs({
        [new_name] = replaces_str,
        [new_id] = replaces_num
    }) do
        for c, v in pairs(data) do
            if string.find(s, v, nil, true) then
                s = string.gsub(s, v, c)
            elseif string.find(s, string.lower(v), nil, true) then
                s = string.gsub(s, string.lower(v), string.lower(c))
            elseif string.find(s, string.upper(v), nil, true) then
                s = string.gsub(s, string.upper(v), string.upper(c))
            elseif string.find(string.upper(s), string.upper(v), nil, true) then
                s = string.gsub(s, casepatt(v), c)
            end
        end
    end
    return s
end
if filter_httpget.enabled and type(hookfunc or hookfunction or detour_function) == "function" then
    local hget
    hget = assert(hookfunction or hookfunc or detour_function, "Hook function required for filter_httpget")(assert(game.HttpGet, "HttpGet required for filter_httpget"), function(shelf, u, ...)
        if filter_httpget.request then
            local x, e = pcall(filterstr, u)
            if x and e then
                u = e
            end
        end
        if filter_httpget.result then
            local result = hget(shelf, u, ...)
            local x, e = pcall(filterstr, result)
            if x and e then
                return e
            end
        end
        return hget(shelf, u, ...)
    end)
end
scan_and_replace(true)
while wait(1) do
    if rename_instances then
        Players.LocalPlayer.Name = new_name
        if Players.LocalPlayer.Character then
            Players.LocalPlayer.Character.Name = new_name
        end
    end
    if change_id then
        Players.LocalPlayer.UserId = tonumber(tonumber(new_id or 1) or 1)
    end
    scan_and_replace()
end
   end,
})

local Button = ClientSidedTab:CreateButton({
   Name = "Free star",
   Callback = function()
   local new_name = "[‚≠ê] Shoota"
local new_id = 104867 -- I'm not 26346. ^_^
local clear_avatar = true -- So no one can reverse search by your outfit
local flush_body_colors = true -- So no one can reverse search by your bodycolors
local rename_instances = false -- Rename any instances that holds your name. (Not recomended unless you can see your name above your character)
local change_id = false -- Change your player ID (not visually)
local deep_scan = true -- Can get a bit laggy if there is a mass wave of new instances
local filter_httpget = { -- Didn't seem like this would be helpful, but requested.
    enabled = false, -- Turn on
    result = true, -- Filter the results of the request
    request = true -- Filter the url before requesting
}


local Players = assert(assert(game, "game missing?"):FindService("Players") or game:GetService("Players"), "Players missing?")
local LocalPlayer = assert(Players.LocalPlayer, "LocalPlayer missing?")
local CoreGui = game:FindService("CoreGui") or game:GetService("CoreGui")
local PlayerGui = assert(LocalPlayer:FindFirstChild("PlayerGui"), "PlayerGui mising?")
local RunService = assert(game:FindService("RunService") or game:GetService("RunService"), "RunService missing?")
local replaces_str = {
    Players.LocalPlayer.Name
}
local replaces_num = {
    tostring(Players.LocalPlayer.UserId)
}
new_name, new_id = tostring(new_name), tostring(new_id)
local function casepatt(pattern)
    return string.gsub(pattern, "(%%?)(.)", function(percent, letter)
        if percent ~= "" or not string.match(letter, "%a") then
            return percent .. letter
        else
            return string.format("[%s%s]", string.lower(letter), string.upper(letter))
        end
    end)
end
function replace(item, fast)
    for replacewith, data in pairs({
        [new_name] = replaces_str,
        [new_id] = replaces_num
    }) do
        if not fast then
            RunService.RenderStepped:Wait()
        end
        for _, v in pairs(data) do
            if not fast then
                RunService.RenderStepped:Wait()
            end
            for _, t in pairs({
                "Text",
                "Message",
                "ToolTip",
                "Value"
            }) do
                pcall(function()
                    if string.find(item[t], v, nil, true) then
                        item[t] = string.gsub(item[t], v, replacewith)
                    elseif string.find(item[t], string.lower(v), nil, true) then
                        item[t] = string.gsub(item[v], string.lower(v), string.lower(replacewith))
                    elseif string.find(item[t], string.upper(v), nil, true) then
                        item[t] = string.gsub(item[v], string.upper(v), string.upper(replacewith))
                    elseif string.find(string.lower(item[t]), string.lower(v), nil, true) then
                        item[t] = string.gsub(item[v], casepatt(v), replacewith)
                    end
                end)
                if not fast then
                    RunService.RenderStepped:Wait()
                end
            end
            if not fast then
                RunService.RenderStepped:Wait()
            end
            if rename_instances then
                pcall(function()
                    if string.find(item.Name, v, nil, true) then
                        item.Name = string.gsub(item.Name, v, replacewith)
                    elseif string.find(item.Name, string.lower(v), nil, true) then
                        item.Name = string.gsub(item.Name, string.lower(v), string.lower(replacewith))
                    elseif string.find(item.Name, string.upper(v), nil, true) then
                        item.Name = string.gsub(item.Name, string.lower(v), string.upper(replacewith))
                    elseif string.find(string.lower(item.Name), string.lower(v), nil, true) then
                        item.Name = string.gsub(item.Name, casepatt(v), replacewith)
                    end
                end)
            end
        end
    end
end
shared.rep = replace
local function scan_and_replace(fast)
    local scan_que = {
        CoreGui:GetDescendants(),
        PlayerGui:GetDescendants(),
        workspace:GetDescendants()
    }
    local last_break = 0
    for _, items in pairs(scan_que) do
        if not fast then
            RunService.RenderStepped:Wait()
        end
        for _, gui in pairs(assert(type(items) == "table" and items, "scan_que does not hold a table")) do
            last_break = 1 + last_break
            if last_break >= 6000 then
                RunService.RenderStepped:Wait()
                last_break = 0
            end
            if not fast then
                RunService.RenderStepped:Wait()
            end
            replace(gui, fast)
        end
    end
    for _, obj in pairs(workspace:GetDescendants()) do
        if not fast then
            RunService.RenderStepped:Wait()
        end
        replace(obj)
    end
end
function fixchar(Character)
    if not Character then
        return 
    end
	wait(0.2)
    RunService.RenderStepped:Wait()
    if rename_instances then
        Character.Name = new_name
    end
	if clear_avatar then
    	Players.LocalPlayer:ClearCharacterAppearance()
	end
    wait(0.1)
    if flush_body_colors then
        local bc = Character:FindFirstChildOfClass("BodyColors")
        if bc then
            for _, c in pairs({
                "HeadColor",
                "LeftArmColor",
                "LeftLegColor",
                "RightArmColor",
                "RightLegColor",
                "TorsoColor"
            }) do
                bc[c] = (typeof(bc[c]) == "BrickColor" and BrickColor.Random()) or bc[c]
            end
        else
            local h = Character:FindFirstChildOfClass("Humanoid")
            if h then
                for _, limb in pairs(Character:GetChildren()) do
                    if limb:IsA("BasePart") and pcall(h.GetLimb, h, limb) then
                        limb.BrickColor = BrickColor.Random()
                    end
                end
            end
        end
    end
end
fixchar(Players.LocalPlayer.Character)
Players.LocalPlayer.CharacterAppearanceLoaded:Connect(fixchar)
Players.LocalPlayer.CharacterAdded:Connect(fixchar)
if deep_scan then
    game.ItemChanged:Connect(function(obj, property)
        if not rename_instances and "Name" == property then
            return 
        end
        local s, v = pcall(function()
            return obj[property]
        end)
        if s then
            if "string" == type(v) then
                for _, c in pairs(replaces_str) do
                    RunService.RenderStepped:Wait()
                    if string.find(obj[property], c, nil, true) then
                        obj[property] = string.gsub(tostring(obj[property] or v), c, new_name)
                    elseif string.find(obj[property], string.lower(c)) then
                        obj[property] = string.gsub(tostring(obj[property] or v), string.lower(c), string.lower(new_name))
                    elseif string.find(obj[property], string.upper(c), nil, true) then
                        obj[property] = string.gsub(tostring(obj[property] or v), string.upper(c), string.upper(new_name))
                    elseif string.find(string.upper(obj[property]), string.upper(c), nil, true) then
                        obj[property] = string.gsub(tostring(obj[property] or v), casepatt(c), new_name)
                    end
                end
                RunService.RenderStepped:Wait()
                for _, c in pairs(replaces_num) do
                    RunService.RenderStepped:Wait()
                    if string.find(obj[property], new_id) then
                        obj[property] = string.gsub(tostring(obj[property] or v), c, new_id)
                    end
                end
            elseif "number" == type(v) then
                v = tostring(obj[property] or v)
                for _, c in pairs(replaces_num) do
                    RunService.RenderStepped:Wait()
                    if string.find(v, c) then
                        obj[property] = tonumber(tonumber(string.gsub(v, c, new_id) or obj[property]) or obj[property])
                    end
                end
            end
        end
    end)
    CoreGui.DescendantAdded:Connect(replace)
    PlayerGui.DescendantAdded:Connect(replace)
end
local function filterstr(s)
    for _, data in pairs({
        [new_name] = replaces_str,
        [new_id] = replaces_num
    }) do
        for c, v in pairs(data) do
            if string.find(s, v, nil, true) then
                s = string.gsub(s, v, c)
            elseif string.find(s, string.lower(v), nil, true) then
                s = string.gsub(s, string.lower(v), string.lower(c))
            elseif string.find(s, string.upper(v), nil, true) then
                s = string.gsub(s, string.upper(v), string.upper(c))
            elseif string.find(string.upper(s), string.upper(v), nil, true) then
                s = string.gsub(s, casepatt(v), c)
            end
        end
    end
    return s
end
if filter_httpget.enabled and type(hookfunc or hookfunction or detour_function) == "function" then
    local hget
    hget = assert(hookfunction or hookfunc or detour_function, "Hook function required for filter_httpget")(assert(game.HttpGet, "HttpGet required for filter_httpget"), function(shelf, u, ...)
        if filter_httpget.request then
            local x, e = pcall(filterstr, u)
            if x and e then
                u = e
            end
        end
        if filter_httpget.result then
            local result = hget(shelf, u, ...)
            local x, e = pcall(filterstr, result)
            if x and e then
                return e
            end
        end
        return hget(shelf, u, ...)
    end)
end
scan_and_replace(true)
while wait(1) do
    if rename_instances then
        Players.LocalPlayer.Name = new_name
        if Players.LocalPlayer.Character then
            Players.LocalPlayer.Character.Name = new_name
        end
    end
    if change_id then
        Players.LocalPlayer.UserId = tonumber(tonumber(new_id or 1) or 1)
    end
    scan_and_replace()
end
   end,
})

local Button = ClientSidedTab:CreateButton({
   Name = "Free Host",
   Callback = function()
   local new_name = "[‚ú®] Shoota"
local new_id = 104867 -- I'm not 26346. ^_^
local clear_avatar = true -- So no one can reverse search by your outfit
local flush_body_colors = true -- So no one can reverse search by your bodycolors
local rename_instances = false -- Rename any instances that holds your name. (Not recomended unless you can see your name above your character)
local change_id = false -- Change your player ID (not visually)
local deep_scan = true -- Can get a bit laggy if there is a mass wave of new instances
local filter_httpget = { -- Didn't seem like this would be helpful, but requested.
    enabled = false, -- Turn on
    result = true, -- Filter the results of the request
    request = true -- Filter the url before requesting
}


local Players = assert(assert(game, "game missing?"):FindService("Players") or game:GetService("Players"), "Players missing?")
local LocalPlayer = assert(Players.LocalPlayer, "LocalPlayer missing?")
local CoreGui = game:FindService("CoreGui") or game:GetService("CoreGui")
local PlayerGui = assert(LocalPlayer:FindFirstChild("PlayerGui"), "PlayerGui mising?")
local RunService = assert(game:FindService("RunService") or game:GetService("RunService"), "RunService missing?")
local replaces_str = {
    Players.LocalPlayer.Name
}
local replaces_num = {
    tostring(Players.LocalPlayer.UserId)
}
new_name, new_id = tostring(new_name), tostring(new_id)
local function casepatt(pattern)
    return string.gsub(pattern, "(%%?)(.)", function(percent, letter)
        if percent ~= "" or not string.match(letter, "%a") then
            return percent .. letter
        else
            return string.format("[%s%s]", string.lower(letter), string.upper(letter))
        end
    end)
end
function replace(item, fast)
    for replacewith, data in pairs({
        [new_name] = replaces_str,
        [new_id] = replaces_num
    }) do
        if not fast then
            RunService.RenderStepped:Wait()
        end
        for _, v in pairs(data) do
            if not fast then
                RunService.RenderStepped:Wait()
            end
            for _, t in pairs({
                "Text",
                "Message",
                "ToolTip",
                "Value"
            }) do
                pcall(function()
                    if string.find(item[t], v, nil, true) then
                        item[t] = string.gsub(item[t], v, replacewith)
                    elseif string.find(item[t], string.lower(v), nil, true) then
                        item[t] = string.gsub(item[v], string.lower(v), string.lower(replacewith))
                    elseif string.find(item[t], string.upper(v), nil, true) then
                        item[t] = string.gsub(item[v], string.upper(v), string.upper(replacewith))
                    elseif string.find(string.lower(item[t]), string.lower(v), nil, true) then
                        item[t] = string.gsub(item[v], casepatt(v), replacewith)
                    end
                end)
                if not fast then
                    RunService.RenderStepped:Wait()
                end
            end
            if not fast then
                RunService.RenderStepped:Wait()
            end
            if rename_instances then
                pcall(function()
                    if string.find(item.Name, v, nil, true) then
                        item.Name = string.gsub(item.Name, v, replacewith)
                    elseif string.find(item.Name, string.lower(v), nil, true) then
                        item.Name = string.gsub(item.Name, string.lower(v), string.lower(replacewith))
                    elseif string.find(item.Name, string.upper(v), nil, true) then
                        item.Name = string.gsub(item.Name, string.lower(v), string.upper(replacewith))
                    elseif string.find(string.lower(item.Name), string.lower(v), nil, true) then
                        item.Name = string.gsub(item.Name, casepatt(v), replacewith)
                    end
                end)
            end
        end
    end
end
shared.rep = replace
local function scan_and_replace(fast)
    local scan_que = {
        CoreGui:GetDescendants(),
        PlayerGui:GetDescendants(),
        workspace:GetDescendants()
    }
    local last_break = 0
    for _, items in pairs(scan_que) do
        if not fast then
            RunService.RenderStepped:Wait()
        end
        for _, gui in pairs(assert(type(items) == "table" and items, "scan_que does not hold a table")) do
            last_break = 1 + last_break
            if last_break >= 6000 then
                RunService.RenderStepped:Wait()
                last_break = 0
            end
            if not fast then
                RunService.RenderStepped:Wait()
            end
            replace(gui, fast)
        end
    end
    for _, obj in pairs(workspace:GetDescendants()) do
        if not fast then
            RunService.RenderStepped:Wait()
        end
        replace(obj)
    end
end
function fixchar(Character)
    if not Character then
        return 
    end
	wait(0.2)
    RunService.RenderStepped:Wait()
    if rename_instances then
        Character.Name = new_name
    end
	if clear_avatar then
    	Players.LocalPlayer:ClearCharacterAppearance()
	end
    wait(0.1)
    if flush_body_colors then
        local bc = Character:FindFirstChildOfClass("BodyColors")
        if bc then
            for _, c in pairs({
                "HeadColor",
                "LeftArmColor",
                "LeftLegColor",
                "RightArmColor",
                "RightLegColor",
                "TorsoColor"
            }) do
                bc[c] = (typeof(bc[c]) == "BrickColor" and BrickColor.Random()) or bc[c]
            end
        else
            local h = Character:FindFirstChildOfClass("Humanoid")
            if h then
                for _, limb in pairs(Character:GetChildren()) do
                    if limb:IsA("BasePart") and pcall(h.GetLimb, h, limb) then
                        limb.BrickColor = BrickColor.Random()
                    end
                end
            end
        end
    end
end
fixchar(Players.LocalPlayer.Character)
Players.LocalPlayer.CharacterAppearanceLoaded:Connect(fixchar)
Players.LocalPlayer.CharacterAdded:Connect(fixchar)
if deep_scan then
    game.ItemChanged:Connect(function(obj, property)
        if not rename_instances and "Name" == property then
            return 
        end
        local s, v = pcall(function()
            return obj[property]
        end)
        if s then
            if "string" == type(v) then
                for _, c in pairs(replaces_str) do
                    RunService.RenderStepped:Wait()
                    if string.find(obj[property], c, nil, true) then
                        obj[property] = string.gsub(tostring(obj[property] or v), c, new_name)
                    elseif string.find(obj[property], string.lower(c)) then
                        obj[property] = string.gsub(tostring(obj[property] or v), string.lower(c), string.lower(new_name))
                    elseif string.find(obj[property], string.upper(c), nil, true) then
                        obj[property] = string.gsub(tostring(obj[property] or v), string.upper(c), string.upper(new_name))
                    elseif string.find(string.upper(obj[property]), string.upper(c), nil, true) then
                        obj[property] = string.gsub(tostring(obj[property] or v), casepatt(c), new_name)
                    end
                end
                RunService.RenderStepped:Wait()
                for _, c in pairs(replaces_num) do
                    RunService.RenderStepped:Wait()
                    if string.find(obj[property], new_id) then
                        obj[property] = string.gsub(tostring(obj[property] or v), c, new_id)
                    end
                end
            elseif "number" == type(v) then
                v = tostring(obj[property] or v)
                for _, c in pairs(replaces_num) do
                    RunService.RenderStepped:Wait()
                    if string.find(v, c) then
                        obj[property] = tonumber(tonumber(string.gsub(v, c, new_id) or obj[property]) or obj[property])
                    end
                end
            end
        end
    end)
    CoreGui.DescendantAdded:Connect(replace)
    PlayerGui.DescendantAdded:Connect(replace)
end
local function filterstr(s)
    for _, data in pairs({
        [new_name] = replaces_str,
        [new_id] = replaces_num
    }) do
        for c, v in pairs(data) do
            if string.find(s, v, nil, true) then
                s = string.gsub(s, v, c)
            elseif string.find(s, string.lower(v), nil, true) then
                s = string.gsub(s, string.lower(v), string.lower(c))
            elseif string.find(s, string.upper(v), nil, true) then
                s = string.gsub(s, string.upper(v), string.upper(c))
            elseif string.find(string.upper(s), string.upper(v), nil, true) then
                s = string.gsub(s, casepatt(v), c)
            end
        end
    end
    return s
end
if filter_httpget.enabled and type(hookfunc or hookfunction or detour_function) == "function" then
    local hget
    hget = assert(hookfunction or hookfunc or detour_function, "Hook function required for filter_httpget")(assert(game.HttpGet, "HttpGet required for filter_httpget"), function(shelf, u, ...)
        if filter_httpget.request then
            local x, e = pcall(filterstr, u)
            if x and e then
                u = e
            end
        end
        if filter_httpget.result then
            local result = hget(shelf, u, ...)
            local x, e = pcall(filterstr, result)
            if x and e then
                return e
            end
        end
        return hget(shelf, u, ...)
    end)
end
scan_and_replace(true)
while wait(1) do
    if rename_instances then
        Players.LocalPlayer.Name = new_name
        if Players.LocalPlayer.Character then
            Players.LocalPlayer.Character.Name = new_name
        end
    end
    if change_id then
        Players.LocalPlayer.UserId = tonumber(tonumber(new_id or 1) or 1)
    end
    scan_and_replace()
end
   end,
})

local Button = ClientSidedTab:CreateButton({
   Name = "Free CheckMark",
   Callback = function()
   local new_name = "[‚òë] Shoota"
local new_id = 104867 -- I'm not 26346. ^_^
local clear_avatar = true -- So no one can reverse search by your outfit
local flush_body_colors = true -- So no one can reverse search by your bodycolors
local rename_instances = false -- Rename any instances that holds your name. (Not recomended unless you can see your name above your character)
local change_id = false -- Change your player ID (not visually)
local deep_scan = true -- Can get a bit laggy if there is a mass wave of new instances
local filter_httpget = { -- Didn't seem like this would be helpful, but requested.
    enabled = false, -- Turn on
    result = true, -- Filter the results of the request
    request = true -- Filter the url before requesting
}


local Players = assert(assert(game, "game missing?"):FindService("Players") or game:GetService("Players"), "Players missing?")
local LocalPlayer = assert(Players.LocalPlayer, "LocalPlayer missing?")
local CoreGui = game:FindService("CoreGui") or game:GetService("CoreGui")
local PlayerGui = assert(LocalPlayer:FindFirstChild("PlayerGui"), "PlayerGui mising?")
local RunService = assert(game:FindService("RunService") or game:GetService("RunService"), "RunService missing?")
local replaces_str = {
    Players.LocalPlayer.Name
}
local replaces_num = {
    tostring(Players.LocalPlayer.UserId)
}
new_name, new_id = tostring(new_name), tostring(new_id)
local function casepatt(pattern)
    return string.gsub(pattern, "(%%?)(.)", function(percent, letter)
        if percent ~= "" or not string.match(letter, "%a") then
            return percent .. letter
        else
            return string.format("[%s%s]", string.lower(letter), string.upper(letter))
        end
    end)
end
function replace(item, fast)
    for replacewith, data in pairs({
        [new_name] = replaces_str,
        [new_id] = replaces_num
    }) do
        if not fast then
            RunService.RenderStepped:Wait()
        end
        for _, v in pairs(data) do
            if not fast then
                RunService.RenderStepped:Wait()
            end
            for _, t in pairs({
                "Text",
                "Message",
                "ToolTip",
                "Value"
            }) do
                pcall(function()
                    if string.find(item[t], v, nil, true) then
                        item[t] = string.gsub(item[t], v, replacewith)
                    elseif string.find(item[t], string.lower(v), nil, true) then
                        item[t] = string.gsub(item[v], string.lower(v), string.lower(replacewith))
                    elseif string.find(item[t], string.upper(v), nil, true) then
                        item[t] = string.gsub(item[v], string.upper(v), string.upper(replacewith))
                    elseif string.find(string.lower(item[t]), string.lower(v), nil, true) then
                        item[t] = string.gsub(item[v], casepatt(v), replacewith)
                    end
                end)
                if not fast then
                    RunService.RenderStepped:Wait()
                end
            end
            if not fast then
                RunService.RenderStepped:Wait()
            end
            if rename_instances then
                pcall(function()
                    if string.find(item.Name, v, nil, true) then
                        item.Name = string.gsub(item.Name, v, replacewith)
                    elseif string.find(item.Name, string.lower(v), nil, true) then
                        item.Name = string.gsub(item.Name, string.lower(v), string.lower(replacewith))
                    elseif string.find(item.Name, string.upper(v), nil, true) then
                        item.Name = string.gsub(item.Name, string.lower(v), string.upper(replacewith))
                    elseif string.find(string.lower(item.Name), string.lower(v), nil, true) then
                        item.Name = string.gsub(item.Name, casepatt(v), replacewith)
                    end
                end)
            end
        end
    end
end
shared.rep = replace
local function scan_and_replace(fast)
    local scan_que = {
        CoreGui:GetDescendants(),
        PlayerGui:GetDescendants(),
        workspace:GetDescendants()
    }
    local last_break = 0
    for _, items in pairs(scan_que) do
        if not fast then
            RunService.RenderStepped:Wait()
        end
        for _, gui in pairs(assert(type(items) == "table" and items, "scan_que does not hold a table")) do
            last_break = 1 + last_break
            if last_break >= 6000 then
                RunService.RenderStepped:Wait()
                last_break = 0
            end
            if not fast then
                RunService.RenderStepped:Wait()
            end
            replace(gui, fast)
        end
    end
    for _, obj in pairs(workspace:GetDescendants()) do
        if not fast then
            RunService.RenderStepped:Wait()
        end
        replace(obj)
    end
end
function fixchar(Character)
    if not Character then
        return 
    end
	wait(0.2)
    RunService.RenderStepped:Wait()
    if rename_instances then
        Character.Name = new_name
    end
	if clear_avatar then
    	Players.LocalPlayer:ClearCharacterAppearance()
	end
    wait(0.1)
    if flush_body_colors then
        local bc = Character:FindFirstChildOfClass("BodyColors")
        if bc then
            for _, c in pairs({
                "HeadColor",
                "LeftArmColor",
                "LeftLegColor",
                "RightArmColor",
                "RightLegColor",
                "TorsoColor"
            }) do
                bc[c] = (typeof(bc[c]) == "BrickColor" and BrickColor.Random()) or bc[c]
            end
        else
            local h = Character:FindFirstChildOfClass("Humanoid")
            if h then
                for _, limb in pairs(Character:GetChildren()) do
                    if limb:IsA("BasePart") and pcall(h.GetLimb, h, limb) then
                        limb.BrickColor = BrickColor.Random()
                    end
                end
            end
        end
    end
end
fixchar(Players.LocalPlayer.Character)
Players.LocalPlayer.CharacterAppearanceLoaded:Connect(fixchar)
Players.LocalPlayer.CharacterAdded:Connect(fixchar)
if deep_scan then
    game.ItemChanged:Connect(function(obj, property)
        if not rename_instances and "Name" == property then
            return 
        end
        local s, v = pcall(function()
            return obj[property]
        end)
        if s then
            if "string" == type(v) then
                for _, c in pairs(replaces_str) do
                    RunService.RenderStepped:Wait()
                    if string.find(obj[property], c, nil, true) then
                        obj[property] = string.gsub(tostring(obj[property] or v), c, new_name)
                    elseif string.find(obj[property], string.lower(c)) then
                        obj[property] = string.gsub(tostring(obj[property] or v), string.lower(c), string.lower(new_name))
                    elseif string.find(obj[property], string.upper(c), nil, true) then
                        obj[property] = string.gsub(tostring(obj[property] or v), string.upper(c), string.upper(new_name))
                    elseif string.find(string.upper(obj[property]), string.upper(c), nil, true) then
                        obj[property] = string.gsub(tostring(obj[property] or v), casepatt(c), new_name)
                    end
                end
                RunService.RenderStepped:Wait()
                for _, c in pairs(replaces_num) do
                    RunService.RenderStepped:Wait()
                    if string.find(obj[property], new_id) then
                        obj[property] = string.gsub(tostring(obj[property] or v), c, new_id)
                    end
                end
            elseif "number" == type(v) then
                v = tostring(obj[property] or v)
                for _, c in pairs(replaces_num) do
                    RunService.RenderStepped:Wait()
                    if string.find(v, c) then
                        obj[property] = tonumber(tonumber(string.gsub(v, c, new_id) or obj[property]) or obj[property])
                    end
                end
            end
        end
    end)
    CoreGui.DescendantAdded:Connect(replace)
    PlayerGui.DescendantAdded:Connect(replace)
end
local function filterstr(s)
    for _, data in pairs({
        [new_name] = replaces_str,
        [new_id] = replaces_num
    }) do
        for c, v in pairs(data) do
            if string.find(s, v, nil, true) then
                s = string.gsub(s, v, c)
            elseif string.find(s, string.lower(v), nil, true) then
                s = string.gsub(s, string.lower(v), string.lower(c))
            elseif string.find(s, string.upper(v), nil, true) then
                s = string.gsub(s, string.upper(v), string.upper(c))
            elseif string.find(string.upper(s), string.upper(v), nil, true) then
                s = string.gsub(s, casepatt(v), c)
            end
        end
    end
    return s
end
if filter_httpget.enabled and type(hookfunc or hookfunction or detour_function) == "function" then
    local hget
    hget = assert(hookfunction or hookfunc or detour_function, "Hook function required for filter_httpget")(assert(game.HttpGet, "HttpGet required for filter_httpget"), function(shelf, u, ...)
        if filter_httpget.request then
            local x, e = pcall(filterstr, u)
            if x and e then
                u = e
            end
        end
        if filter_httpget.result then
            local result = hget(shelf, u, ...)
            local x, e = pcall(filterstr, result)
            if x and e then
                return e
            end
        end
        return hget(shelf, u, ...)
    end)
end
scan_and_replace(true)
while wait(1) do
    if rename_instances then
        Players.LocalPlayer.Name = new_name
        if Players.LocalPlayer.Character then
            Players.LocalPlayer.Character.Name = new_name
        end
    end
    if change_id then
        Players.LocalPlayer.UserId = tonumber(tonumber(new_id or 1) or 1)
    end
    scan_and_replace()
end
   end,
})

local AimingTab = Window:CreateTab("Aiming", nil) -- Title, Image
local AimingSection = AimingTab:CreateSection("locks")

local Button = AimingTab:CreateButton({
   Name = "Tracer Lock",
   Callback = function()
   local Settings = { AimLock = { Enabled = true, Aimlockkey = "q", Prediction = 0.130340, Aimpart = 'HumanoidRootPart', Notifications = true }, Settings = { Thickness = 3.5, Transparency = 1, Color = Color3.fromRGB(106, 13, 173), FOV = true } } local CurrentCamera = game:GetService("Workspace").CurrentCamera local Inset = game:GetService("GuiService"):GetGuiInset().Y local RunService = game:GetService("RunService") local Mouse = game.Players.LocalPlayer:GetMouse() local LocalPlayer = game.Players.LocalPlayer local Line = Drawing.new("Line") local Circle = Drawing.new("Circle") local Plr = game.Players.LocalPlayer Mouse.KeyDown:Connect(function(KeyPressed) if KeyPressed == (Settings.AimLock.Aimlockkey) then if Settings.AimLock.Enabled == true then Settings.AimLock.Enabled = false if Settings.AimLock.Notifications == true then Plr = FindClosestPlayer() game.StarterGui:SetCore("SendNotification", { Title = "p", Text = "Unlocked" }) end else Plr = FindClosestPlayer() Settings.AimLock.Enabled = true if Settings.AimLock.Notifications == true then game.StarterGui:SetCore("SendNotification", { Title = "p", Text = "Locked On : " .. tostring(Plr.Character.Humanoid.DisplayName) }) end end end end) function FindClosestPlayer() local ClosestDistance, ClosestPlayer = math.huge, nil; for _, Player in next, game:GetService("Players"):GetPlayers() do if Player ~= LocalPlayer then local Character = Player.Character if Character and Character.Humanoid.Health > 1 then local Position, IsVisibleOnViewPort = CurrentCamera:WorldToViewportPoint(Character.HumanoidRootPart .Position) if IsVisibleOnViewPort then local Distance = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(Position.X, Position.Y)).Magnitude if Distance < ClosestDistance then ClosestPlayer = Player ClosestDistance = Distance end end end end end return ClosestPlayer, ClosestDistance end RunService.Heartbeat:connect(function() if Settings.AimLock.Enabled == true then local Vector = CurrentCamera:WorldToViewportPoint(Plr.Character[Settings.AimLock.Aimpart].Position + (Plr.Character[Settings.AimLock.Aimpart].Velocity * Settings.AimLock.Prediction)) Line.Color = Settings.Settings.Color Line.Transparency = Settings.Settings .Transparency Line.Thickness = Settings.Settings .Thickness Line.From = Vector2.new(Mouse.X, Mouse.Y + Inset) Line.To = Vector2.new(Vector.X, Vector.Y) Line.Visible = true Circle.Position = Vector2.new(Mouse.X, Mouse.Y + Inset) Circle.Visible = Settings.Settings.FOV Circle.Thickness = 1.5 Circle.Thickness = 2 Circle.Radius = 60 Circle.Color = Settings.Settings.Color elseif Settings.AimLock.FOV == true then Circle.Visible = true else Circle.Visible = false Line.Visible = false end end) local mt = getrawmetatable(game) local old = mt.__namecall setreadonly(mt, false) mt.__namecall = newcclosure(function(...) local args = {...} if Settings.AimLock.Enabled and getnamecallmethod() == "FireServer" and args[2] == "MousePos" then args[3] = Plr.Character[Settings.AimLock.Aimpart].Position + (Plr.Character[Settings.AimLock.Aimpart].Velocity * Settings.AimLock.Prediction) return old(unpack(args)) end return old(...) end)
   end,
})

local Button = AimingTab:CreateButton({
   Name = "Slient Aim",
   Callback = function()
   _G.FOV =  (  200  )
_G.Prediction =  (  .18  )
_G.AimKey =  (  "q"  )
loadstring(game:HttpGet(("https://raw.githubusercontent.com/Nessa-Rurina/Nosslock/main/SilentAim.lua"), true))()
   end,
})

local Button = AimingTab:CreateButton({
   Name = "Cam Lock",
   Callback = function()
   --.gg/lockers runs you
--Made by sparkyz
getgenv().Prediction = 0.1452833
getgenv().AimPart = "HumanoidRootPart"
getgenv().Key = "Q"
getgenv().DisableKey = "P"
getgenv().FOV = true
getgenv().ShowFOV = false
getgenv().FOVSize = 100
--// Variables (Service)
local Players = game:GetService("Players")
local RS = game:GetService("RunService")
local WS = game:GetService("Workspace")
local GS = game:GetService("GuiService")
local SG = game:GetService("StarterGui")
--// Variables (regular)
local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()
local Camera = WS.CurrentCamera
local GetGuiInset = GS.GetGuiInset
local AimlockState = true
local Locked
local Victim
local SelectedKey = getgenv().Key
local SelectedDisableKey = getgenv().DisableKey
--// Notification function
function Notify(tx)
    SG:SetCore("SendNotification", {
        Title = "Cam Lock Enabled | .gg/thusky",
        Text = tx,
        Duration = 5
    })
end
--// Check if aimlock is loaded
if getgenv().Loaded == true then
    Notify("Aimlock is already loaded!")
    return
end
getgenv().Loaded = true
--// FOV Circle
local fov = Drawing.new("Circle")
fov.Filled = false
fov.Transparency = 1
fov.Thickness = 1
fov.Color = Color3.fromRGB(255, 255, 0)
fov.NumSides = 1000
--// Functions
function update()
    if getgenv().FOV == true then
        if fov then
            fov.Radius = getgenv().FOVSize * 2
            fov.Visible = getgenv().ShowFOV
            fov.Position = Vector2.new(Mouse.X, Mouse.Y + GetGuiInset(GS).Y)
            return fov
        end
    end
end
function WTVP(arg)
    return Camera:WorldToViewportPoint(arg)
end
function WTSP(arg)
    return Camera.WorldToScreenPoint(Camera, arg)
end
function getClosest()
    local closestPlayer
    local shortestDistance = math.huge
    for i, v in pairs(game.Players:GetPlayers()) do
        local notKO = v.Character:WaitForChild("BodyEffects")["K.O"].Value ~= true
        local notGrabbed = v.Character:FindFirstChild("GRABBING_COINSTRAINT") == nil
 
        if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild(getgenv().AimPart) and notKO and notGrabbed then
            local pos = Camera:WorldToViewportPoint(v.Character.PrimaryPart.Position)
            local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(Mouse.X, Mouse.Y)).magnitude
 
            if (getgenv().FOV) then
                if (fov.Radius > magnitude and magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            else
                if (magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
    end
    return closestPlayer
end
 
--// Checks if key is down
Mouse.KeyDown:Connect(function(k)
    SelectedKey = SelectedKey:lower()
    SelectedDisableKey = SelectedDisableKey:lower()
    if k == SelectedKey then
        if AimlockState == true then
            Locked = not Locked
            if Locked then
                Victim = getClosest()
                Notify("Locked onto: "..tostring(Victim.Character.Humanoid.DisplayName))
            else
                if Victim ~= nil then
                    Victim = nil
                    Notify("Unlocked!")
                end
            end
        else
            Notify("Aimlock is not enabled!")
        end
    end
    if k == SelectedDisableKey then
        AimlockState = not AimlockState
    end
end)
--// Loop update FOV and loop camera lock onto target
RS.RenderStepped:Connect(function()
    update()
    if AimlockState == true then
        if Victim ~= nil then
            Camera.CFrame = CFrame.new(Camera.CFrame.p, Victim.Character[getgenv().AimPart].Position + Victim.Character[getgenv().AimPart].Velocity*getgenv().Prediction)
        end
    end
end)
	while wait() do
        if getgenv().AutoPrediction == true then
        local pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local split = string.split(pingvalue,'(')
        local ping = tonumber(split[1])
            if ping < 225 then
            getgenv().Prediction = 1.4
        elseif ping < 215 then
            getgenv().Prediction = 1.2
	    elseif ping < 205 then
            getgenv().Prediction = 1.0
	    elseif ping < 190 then
            getgenv().Prediction = 0.10
        elseif ping < 180 then
            getgenv().Prediction = 0.12
	    elseif ping < 170 then
            getgenv().Prediction = 0.15
	    elseif ping < 160 then
            getgenv().Prediction = 0.18
	    elseif ping < 150 then
            getgenv().Prediction = 0.110
        elseif ping < 140 then
            getgenv().Prediction = 0.113
        elseif ping < 130 then
            getgenv().Prediction = 0.116
        elseif ping < 120 then
            getgenv().Prediction = 0.120
        elseif ping < 110 then
            getgenv().Prediction = 0.124
        elseif ping < 105 then
            getgenv().Prediction = 0.127
        elseif ping < 90 then
            getgenv().Prediction = 0.130
        elseif ping < 80 then
            getgenv().Prediction = 0.133
        elseif ping < 70 then
            getgenv().Prediction = 0.136
        elseif ping < 60 then
            getgenv().Prediction = 0.15038
        elseif ping < 50 then
            getgenv().Prediction = 0.15038
        elseif ping < 40 then
            getgenv().Prediction = 0.145
        elseif ping < 30 then
            getgenv().Prediction = 0.155
        elseif ping < 20 then
            getgenv().Prediction = 0.157
        end
        end
	end
   end,
})

local AimingSection = AimingTab:CreateSection("Aim Viewer")

local Button = AimingTab:CreateButton({
   Name = "Aim Viewer",
   Callback = function()
   getgenv().LuckyHub = {
    Preload = {
        ["Notifications"] = true, -- // Global notifications toggle
        ["Intro"] = true, -- // Enables short intro
        ["UseGUI"] = false, -- // Uses GUI // Doesnt use settings below
        ["VelocityStats"] = true, -- // Enables velocity stats
    },
    Underground = {
        ["Enabled"] = true, -- // Underground enabled
        ["Keybind"] = "P", -- // Underground keybind
        ["Amount"] = 1000, -- // Underground amount
    },
    Sky = {
        ["Enabled"] = true, -- // Sky enabled
        ["Keybind"] = "L", -- // Sky keybind
        ["Amount"] = 1000, -- // Sky amount
    },
    CustomVelocity = {
        ["Enabled"] = true, -- // Custom velocity enabled
        ["Keybind"] = "H", -- // Custom velocity keybind
        ["CustomX"] = 2000, -- // Custom velocity custom X
        ["CustomY"] = 100, -- // Custom velocity custom Y
        ["CustomZ"] = 1000, -- // Custom velocity custom Z
    },
    PredictionChanger = {
        ["Enabled"] = true, -- // Prediction Changer enabled
        ["Keybind"] = "B", -- // Prediction changer keybind
        ["Amount"] = 10, -- // Prediction changer amount // Use 0 for prediction disabler
    },
    SpinbotDesync = {
        ["Enabled"] = true, -- // Spinbot desync enabled
        ["Keybind"] = "J", -- // Spinbot desync keybind
        ["Amount"] = 10000, -- // Spinbot desync amount
        ["DesyncAngles"] = 500, -- // Basically how fast you spin
    },
    NetworkDesync = {
        ["Enabled"] = true, -- // Network desync enabled
        ["Keybind"] = "V", -- // Network desync keybind
        ["Amount"] = 2, -- // 2 Recommended
    },
    Shake = {
        ["Enabled"] = true, -- // Shake enabled
        ["Keybind"] = "N", -- // Shake keybind
        ["CustomX"] = 5500, -- // Custom shake X
        ["CustomY"] = 9000, -- // Custom shake Y
        ["CustomZ"] = 3000, -- // Custom shake Z
    },
    AimViewer = {
        ["Enabled"] = true, -- // Aim viewer enabled
        ["Keybind"] = "T", -- // Aim viewer keybind
        ["Width"] = 0.3, -- // Aim viewer width
        ["RainbowMode"] = true, -- // Rainbow aim viewer if true will not use color below
        ["Color"] = Color3.fromRGB(0, 255, 0), -- // Aim viewer color
        ["ViewTarget"] = true, -- // Views target
        ["HighlightTarget"] = true, -- // Enables highlight target
        ["RainbowHighlight"] = true, -- // If true it wont use colors below
        ["FillColor"] = Color3.fromRGB(0, 255, 0), -- // Highlight fill color
        ["OutlineColor"] = Color3.fromRGB(255, 255, 255), -- // Hightlight outline color
        ["Material"] = "Neon", -- // Aim viewer material
        ["Method"] = "MousePos", -- // Dont change unless you know what you are doing
    },
}
--
loadstring(game:HttpGet('https://raw.githubusercontent.com/CoolKid52321/LuckyHub/main/AntilockMain', true))()
 end,
})

local TogglesTab = Window:CreateTab("Toggles", nil) -- Title, Image
local TogglesSection = TogglesTab:CreateSection("Toggles")

local Button = MiscTab:CreateButton({
   Name = "Anti Ban",
   Callback = function()
   --[[Made by ThroughTheFireAndFlames#9925 |

         Anti Report [Universal]

--]]------------------------------------

getgenv().ForbiddenWords = {"hack","exploit","script","report","cheat","executor","skid","owner","creator","admin","staff","anti","mod"} -- Listens to these keywords no matter if they are capital letters or not

getgenv().Reaction = function() -- Serverhopper: Was not made by me but used rightfully as a open source tool for everyone to look at.
        local HttpService, TPService = game:GetService("HttpService"), game:GetService("TeleportService");
        local OtherServers = HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"));
        function joinNew()
                if not isfile("servers.sss") then
                        writefile("servers.sss", HttpService:JSONEncode({}));
                end
                local dontJoin = readfile("servers.sss");
                dontJoin = HttpService:JSONDecode(dontJoin);
                for Index, Server in next, OtherServers['data'] do
                        if (Server ~= game.JobId) then
                                local j = true;
                                for a, c in pairs(dontJoin) do
                                        if (c == Server.id) then
                                                j = false;
                                        end
                                end
                                if j then
                                        table.insert(dontJoin, Server['id']);
                                        writefile("servers.sss", HttpService:JSONEncode(dontJoin));
                                        wait();
                                        return Server['id'];
                                end
                        end
                end
        end
        local server = joinNew();
        if not server then
                writefile("servers.sss", HttpService:JSONEncode({}));
                local server = joinNew();
                TPService:TeleportToPlaceInstance(game.PlaceId, server);
        else
                TPService:TeleportToPlaceInstance(game.PlaceId, server);
        end
end;

loadstring(game:HttpGet("https://raw.githubusercontent.com/Lvl9999/AntiReport/main/Universal"))();
   end,
})
